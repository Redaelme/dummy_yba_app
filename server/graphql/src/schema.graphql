### This file was generated by Nexus Schema
### Do not make changes to this file directly


input AcceptMailInput {
  appointmentUserAction: String!
  emailPayload: String!
  id: String!
}

input AcceptMailWithoutSlotProposalInput {
  calendar: String!
  from: String!
  location: String!
  slotProposal: [String]!
  subject: String!
  to: String!
}

input AcceptMailWithVisioInput {
  date: String!
  from: String!
  subject: String!
  to: String!
}

input AddressInput {
  adresse: String!
  isRemoved: Boolean!
  libelle: String!
  userId: String!
}

type AddressType {
  adresse: String!
  defaultAddress: Boolean!
  fromRemote: Boolean!
  id: String!
  isRemoved: Boolean
  libelle: String!
  userId: String
}

input AppointmentsShedulerInput {
  addressId: String
  buildingId: String!
  capacity: Int
  debut: DateTime!
  duration: Int!
  email: String!
  eventId: String
  fin: DateTime!
  fullName: String
  lang: String
  lastName: String
  localisation: Localisation!
  meetingRescheduled: Boolean
  niveau: String!
  objet: String!
  reminder: String!
  scheduleId: String
  sujet: String
  template: String
  userInvited: [UserInfoInput]
  UTC: Int!
}

type Attendees {
  email: String
  name: String
  responseStatus: String
}

type AuthUser {
  completedSignUp: Boolean
  token: String!
  user: User!
}

type AuthUserBO {
  token: String!
  userBO: UserBO!
}

input BookingLinkInput {
  bookingTimes: BookingTimesInput
  duration: Int!
  expirationDuration: Int!
  language: String!
  level: String!
  userId: String!
}

type BookingTime {
  end: String!
  isAvailable: Boolean!
  start: String!
}

input BookingTimeInput {
  end: String!
  isAvailable: Boolean!
  start: String!
}

type BookingTimes {
  friday: BookingTime
  monday: BookingTime
  saturday: BookingTime
  sunday: BookingTime
  thursday: BookingTime
  tuesday: BookingTime
  wednesday: BookingTime
}

input BookingTimesInput {
  friday: BookingTimeInput
  monday: BookingTimeInput
  saturday: BookingTimeInput
  sunday: BookingTimeInput
  thursday: BookingTimeInput
  tuesday: BookingTimeInput
  wednesday: BookingTimeInput
}

type CalendarEvent {
  attendees: [Attendees]
  colorId: String
  created: String
  creator: String
  description: String
  end: DateTime
  etag: String
  eventType: String
  htmlLink: String
  id: String
  kind: String
  lang: String
  level: String
  location: String
  onlineMeeting: String
  organizer: String
  reminderMinutesBeforeStart: Int
  start: DateTime
  status: String
  subject: String
  summary: String
  updated: String
}

input CalendarInputs {
  debut: DateTime!
  fin: DateTime!
}

enum CalendarTypes {
  APPLE_CALENDAR
  GOOGLE
}

input ChangePasswordInput {
  email: String!
  newPassword: String!
}

type CompleteIncomingMessage {
  incomingEmails: [IncomingEmail]
  userId: String!
}

type Contact {
  displayName: String!
  emailAddresses: [String]!
}

input DateInputs {
  debut: DateTime!
  fin: DateTime!
}

"""Date custom scalar type"""
scalar DateTime

input EmailToTrainTheModelInput {
  content: String
  object: String
}

type EmailToTrainTheModelType {
  content: String
  id: String!
  object: String
}

type EmailUserInfo {
  emailAddress: String!
  name: String!
}

input generateAccessTokenInput {
  serverAuthCode: String!
}

type generateAccessTokenType {
  expiry_date: DateTime!
  refresh_token: String!
  token: String!
  token_type: String!
}

input GetMailInputs {
  maxResult: Int!
}

input getRoomsInputs {
  maxResults: Int
}

type GetUserMail {
  cc: [String]
  content: String
  htmlBody: String
  id: String
  isRead: Boolean
  object: String
  receivedDateTime: String
  recipients: [String]
  sender: SenderType
  subject: String
}

type IncomingEmail {
  cc: [String]
  content: String!
  htmlBody: String
  id: String!
  isRead: Boolean!
  object: String!
  receivedDateTime: DateTime!
  recipients: [String]!
  sender: EmailUserInfo!
}

input IncomingMeetingRequestInput {
  appointmentStatus: String
  appointmentUserAction: String
  contents: String
  dateEntity: String
  eventId: String
  GMT: Int!
  htmlBody: String
  lang: String
  location: String
  mailId: String!
  messageId: String
  object: String
  receivedDatetime: String!
  recipients: String
  schedulePriority: String
  sender: String
  senderFullName: String
  sheduleId: String
  typeMail: String
}

type IncomingMeetingRequestType {
  appointmentStatus: String
  appointmentUserAction: String
  contents: String
  createdAt: DateTime
  dateEntity: String
  eventId: String
  GMT: Int!
  htmlBody: String
  id: String
  lang: String
  location: String
  messageId: String
  object: String
  recipients: String
  schedulePriority: String
  sender: String
  senderFullName: String
  sheduleId: String
  typeMail: String
  updatedAt: DateTime
  userId: String
}

input IncomingRequestInput {
  appointmentStatus: String
  appointmentUserAction: String
  contents: String
  dateEntity: String
  eventId: String
  GMT: Int!
  htmlBody: String
  lang: String
  location: String
  mailId: String!
  object: String
  receivedDatetime: String!
  recipients: String
  schedulePriority: String
  sender: String
  senderFullName: String
  sheduleId: String
  typeMail: String
}

type IncomingRequestType {
  appointmentStatus: String
  appointmentUserAction: String
  contents: String
  createdAt: DateTime
  dateEntity: String
  eventId: String
  GMT: Int!
  htmlBody: String
  id: String
  lang: String
  location: String
  object: String
  recipients: String
  schedulePriority: String
  sender: String
  senderFullName: String
  sheduleId: String
  typeMail: String
  updatedAt: DateTime
  userId: String
}

type InvitedUserInfo {
  email: String!
  required: Boolean!
}

input Localisation {
  location: String!
  visioConf: Boolean!
}

type Location {
  location: String!
  visioConf: Boolean!
}

enum MailService {
  GOOGLE
  MICROSOFT
}

input MailServiceAuthInputs {
  accessToken: String!
  refreshToken: String!
  tokenExpiryDateTime: String!
}

type Matching {
  busy: Boolean!
  eventId: String
}

type MatchingDate {
  end: String!
  start: String!
}

input MatchingInputs {
  date: DateInputs!
  duration: Int
  location: String
  newDate: DateInputs
  typeMail: Int!
  userInvited: [String!]
}

type MatchingList {
  busy: Boolean!
  Date: MatchingDate
  eventId: String
}

input MatchingListInputs {
  dateList: [DateInputs!]!
  duration: Int
  location: String
  mailId: String!
  newDate: [DateInputs]
  typeMail: Int!
  userInvited: [String!]
  UTC: Int
}

type Mutation {
  acceptMail(input: AcceptMailInput!): SuccessReturn
  addAddress(input: AddressInput!): AddressType
  addEmailToTrainTheModel(input: [EmailToTrainTheModelInput]): Boolean
  addIncomingMeetingRequest(inputs: [IncomingMeetingRequestInput]): [IncomingMeetingRequestType]
  addIncomingRequest(inputs: [IncomingRequestInput]): [IncomingRequestType]
  addNotificationToken(token: String!, userId: String!): String
  AppointmentsScheduler(appointmentsInput: AppointmentsShedulerInput!): [TimeSlot]
  changePassword(input: ChangePasswordInput!): User
  checkExpiredToken(email: String!, token: String!): SuccessReturn
  createOauth(data: OauthInput!): Oauth
  createTask(data: TaskInput!): Task
  createUserBookingLink(data: BookingLinkInput): String
  createUserPreference(input: UserPreferenceInputs!): UserPreference
  deleteIncomingMeetingRequest(incomingRequestId: String!): IncomingMeetingRequestType
  deleteIncomingRequest(incomingRequestId: String!): IncomingRequestType
  deleteTask(id: String!): Task
  deleteUserAccount(userId: String!): SuccessReturn
  deleteUserInBO(userId: String!): Boolean
  forgotPassword(email: String!): SuccessReturn
  generateAccessToken(code: String!): generateAccessTokenType
  getUserMail(data: GetMailInputs): [GetUserMail]
  login(deviceToken: String, email: String!, password: String!): AuthUser
  loginBO(email: String!, password: String!): AuthUserBO
  matching(data: MatchingInputs!): Matching
  matchingList(data: MatchingListInputs!): MatchingList
  outlookAppointmentScheduler(appointmentsInputs: AppointmentsShedulerInput!): Boolean
  refusalMail(data: RefusalMailInput!): SuccessReturn
  removeAddress(id: String!, input: AddressInput!): AddressType
  removeEvent(data: removeEventInputs!): Boolean
  removeEventByEventId(eventId: String!, GMT: Int!, userId: String!): SuccessReturn
  removeSchedule(scheduleId: String!): Schedule
  resetPassword(input: ResetPasswordInput!): SuccessReturn
  revokeNotificationToken(token: String!): Boolean
  saveUserFCMToken(token: String!, userId: String!): Boolean
  signUp(userInput: UserCreateInput!): AuthUser
  singupFromBO(userInputBO: UserFromBOInput!): Boolean!
  subscriptionValidation(free: Boolean!): UserBO
  TimeSLotRequest(data: TimeSlotInput!): [TimeSlot]
  updateAddress(id: String!, input: AddressInput!): AddressType
  updateAuth(data: OauthUpdateInput!): String
  updateIncomingMeetingRequest(inputs: UpdateIncomingMeetingRequestInput!): SuccessReturn
  updateIncomingMeetingRequestReceveidDateTimeMutation(data: UpdateIncomingMeetingRequestReceveidDateTimeInputs!): Boolean
  updateIncomingRequest(inputs: UpdateIncomingRequestInput!): SuccessReturn
  updateIncomingRequestReceveidDateTimeMutation(data: UpdateIncomingRequestReceveidDateTimeInputs!): Boolean
  updatePassword(id: String!, newPassword: String!, oldPassword: String!): User
  updateProfile(id: String!, input: UserProfileInput!): User
  updateSchedule(data: UpdateScheduleInputs!, id: String!): Schedule
  updateStatus(isActive: Boolean!, userId: String!): Boolean
  updateTask(data: TaskInput!, id: String!): Task
  updateUserBO(id: String!, newEmail: String, newPassword: String): Boolean
  updateUserMode(beginModeFree: String!, modeFree: Boolean!, userId: String!): User
  updateUserPreference(id: String!, input: UserPreferenceInputs!): UserPreference
}

input notificationUpdateInput {
  email: String!
  token: String!
}

type Oauth {
  access_token: String
  email: String
  id: ID!
}

input OauthInput {
  access_token: String!
  email: String!
}

input OauthUpdateInput {
  email: String!
  refreshToken: String
  token: String
  tokenExpiryDateTime: String
}

type OutlookEmail {
  bodyPreview: String!
  id: String!
  isRead: Boolean!
  sender: OutlookEmailAdress
  subject: String!
  toRecipients: [OutlookEmailAdress]
}

type OutlookEmailAdress {
  address: String
  name: String
}

type OutUsersAll {
  length: Int!
  users: [User]!
}

type Query {
  getAddressById(id: String!): AddressType
  getAllCompany: [User]
  getAllSchedules(userId: String!): [Schedules]
  getAllUser(keyFilterActive: Boolean, keyFilterCompany: String, keySearch: String, limite: Int, offset: Int): OutUsersAll
  getAllUserTasks(userId: String!): [Task]
  getConnectedUserEmails: [OutlookEmail]
  getEventById(id: String!): CalendarEvent
  getEventList(calendarInputs: CalendarInputs!): [CalendarEvent]
  getIncomingMeetingRequests(userId: String!): [IncomingMeetingRequestType]
  getIncomingRequests(userId: String!): [IncomingRequestType]
  getRooms(getRoomsInputs: getRoomsInputs): [RoomsData]
  getSchedule(id: String!): Schedule
  getScheduleByUserAndEventId(eventId: String!, userId: String!): Schedules
  getTaskById(id: String!): Task
  getUserAddresses(userId: String!): [AddressType]
  getUserBookingPreferences(userId: String!): UserBookingLinkPreference
  getUserContacts(userId: String!): [UserContact]
  getUserPreferences(userId: String!): UserPreference
  me: User
  meBO: UserBO
}

input RefusalMailInput {
  appointmentUserAction: String!
  emailPayload: String!
  id: String!
}

input removeEventInputs {
  email: String!
  eventId: String!
}

input ResetPasswordInput {
  email: String!
  newPassword: String!
  token: String!
}

type RoomsData {
  buildingId: String
  capacity: Int
  generatedResourceName: String
  resourceCategory: String
  resourceEmail: String
  resourceName: String
  resourcesId: String
  resourceType: String
}

type Schedule {
  addressId: String
  buildingId: String
  createdAt: DateTime
  debut: DateTime!
  duration: Int!
  email: String!
  fin: DateTime!
  GMT: Int!
  id: String!
  lang: String
  localisation: String
  niveau: String
  objet: String!
  sujet: String
  updatedAt: DateTime
  userInvited: [InvitedUserInfo]
  visioConf: Boolean!
}

type Schedules {
  acceptedSlot: DateTime
  addressId: String
  buildingId: String
  confirmedMessageId: String
  creationDate: String
  debut: DateTime!
  duration: Int!
  email: String!
  eventId: String
  fin: DateTime!
  id: String!
  lang: String
  localisation: String
  messageId: String
  niveau: String
  objet: String!
  personNumber: Int!
  reminder: String!
  status: String!
  sujet: String
  type: String!
  userInvited: [InvitedUserInfo]
  usertoken: String
  visioConf: Boolean!
}

type SenderType {
  emailAddress: String
  name: String
}

type SheduleType {
  duration: Int
  end: DateTime
  start: DateTime
}

input SubtaskInput {
  assignedTo: String!
  deadline: String!
  duration: String!
  endDate: String!
  participants: String!
  priority: String!
  startDate: String!
  title: String!
}

type SuccessReturn {
  message: String!
  success: Boolean!
}

type Task {
  assignedTo: String
  createdAt: String
  deadline: String!
  duration: Int!
  endDate: String
  endTime: String
  id: String!
  mode: String!
  notes: String
  parentTaskId: String
  participants: String
  priority: String
  progress: Int
  scheduleId: String
  startDate: String
  startTime: String
  status: String
  subtasks: [Task]
  tag: String
  timezone: String
  title: String!
  updatedAt: String
  userId: String
}

input TaskInput {
  assignedTo: String!
  deadline: String!
  duration: String!
  endDate: String!
  mode: String!
  participants: String!
  priority: String!
  startDate: String!
  subtasks: [SubtaskInput!]
  tag: String!
  title: String!
}

type TimeSlot {
  end: DateTime
  start: DateTime
}

input TimeSlotInput {
  date: String!
  mail: String!
}

type TimeSlotList {
  TimeList: [TimeSlot]
}

input UpdateIncomingMeetingRequestInput {
  appointmentUserAction: String!
  id: String!
}

input UpdateIncomingMeetingRequestReceveidDateTimeInputs {
  mailId: String!
  receivedDateTime: String!
}

input UpdateIncomingRequestInput {
  appointmentUserAction: String!
  id: String!
}

input UpdateIncomingRequestReceveidDateTimeInputs {
  mailId: String!
  receivedDateTime: String!
}

input UpdateScheduleInputs {
  addressId: String
  buildingId: String
  createdAt: DateTime
  debut: DateTime
  duration: Int
  email: String
  fin: DateTime
  fullName: String
  lang: String
  lastName: String
  localisation: Localisation
  niveau: String
  objet: String
  reminder: String
  sujet: String
  template: String
  updatedAt: DateTime
  userInvited: [UserInfoInput]
  UTC: Int
}

type User {
  avatar: String
  beginModeFree: DateTime
  calendarType: String
  company: String
  contacts: [Contact]
  createdAt: DateTime
  displayName: String
  email: String
  firstName: String
  id: ID!
  isActive: Boolean
  isAdmin: Boolean
  isBanned: Boolean
  isPayed: Boolean
  isRemoved: Boolean
  isSingupBO: Boolean
  lang: String
  lastName: String
  mailService: String
  modeFree: Boolean
  oauthStatus: String
  password: String
  role: UserRole
  signupCompleted: Boolean
  timezone: String
  updatedAt: DateTime
}

type UserBO {
  avatar: String
  email: String
  firstName: String
  id: ID!
  lastName: String
  password: String
  role: String
}

type UserBookingLinkPreference {
  bookingTimes: String
  duration: Int
  expirationDuration: Int
  language: String
  level: String
}

type UserContact {
  displayName: String!
  emailAddresses: [String]!
}

input UserCreateInput {
  calendarType: CalendarTypes!
  email: String!
  firstName: String!
  id: String
  lang: String
  lastName: String!
  mailService: MailService!
  mailServiceAuth: MailServiceAuthInputs!
  notificationToken: String!
  password: String!
  signupCompleted: Boolean
  timezone: String
}

input UserFromBO {
  company: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

input UserFromBOInput {
  input: [UserFromBO]!
}

input UserInfoInput {
  email: String!
  required: Boolean!
}

type UserPreference {
  averageTravelTime: Int
  createdAt: DateTime
  highCanExtendWorkingTimes: Boolean
  highCanRescheduleLow: Boolean
  highCanRescheduleMedium: Boolean
  highCanSkipPauseTimes: Boolean
  hightWorkingHoursBegin: DateTime
  highWorkingHoursEnd: DateTime
  id: ID!
  mediumCanExtendWorkingHours: Boolean
  mediumCanRescheduleLow: Boolean
  mediumCanSkipPauseTimes: Boolean
  mediumWorkingHoursBegin: DateTime
  mediumWorkingHoursEnd: DateTime
  pauseHours: String
  updatedAt: DateTime
  userId: String
  waitngResponseTimeForHIM: Int
  waitngResponseTimeForLIM: Int
  waitngResponseTimeForMIM: Int
  workingDays: String
  workingHoursBegin: DateTime
  workingHoursEnd: DateTime
}

input UserPreferenceInputs {
  averageTravelTime: Int!
  createdAt: DateTime
  highCanExtendWorkingTimes: Boolean!
  highCanRescheduleLow: Boolean!
  highCanRescheduleMedium: Boolean!
  highCanSkipPauseTimes: Boolean!
  hightWorkingHoursBegin: DateTime!
  highWorkingHoursEnd: DateTime!
  mediumCanExtendWorkingHours: Boolean!
  mediumCanRescheduleLow: Boolean!
  mediumCanSkipPauseTimes: Boolean!
  mediumWorkingHoursBegin: DateTime!
  mediumWorkingHoursEnd: DateTime!
  pauseHours: String!
  updatedAt: DateTime
  userId: String!
  waitngResponseTimeForHIM: Int!
  waitngResponseTimeForLIM: Int!
  waitngResponseTimeForMIM: Int!
  workingDays: String!
  workingHoursBegin: DateTime!
  workingHoursEnd: DateTime!
}

input UserProfileInput {
  displayName: String
  email: String
  firstName: String
  lastName: String
}

enum UserRole {
  ADMIN
  USER
}
